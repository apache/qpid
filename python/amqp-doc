#!/usr/bin/env python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
import sys, re
from qpid.spec import load, pythonize
from getopt import gnu_getopt as getopt, GetoptError
from fnmatch import fnmatchcase as fnmatch

def die(msg):
  print >> sys.stderr, msg
  sys.exit(1)

def usage(msg = ""):
  return ("""%s

Usage %s [<options>] [<pattern_1> ... <pattern_n>]

Options:
  -e, --regexp         use regex instead of glob when matching
  -s, --spec <url>     location of amqp.xml
""" % (msg, sys.argv[0])).strip()

try:
  opts, args = getopt(sys.argv[1:], "s:ea:", ["regexp", "spec=", "additional="])
except GetoptError, e:
  die(str(e))

regexp = False
spec = "../specs/amqp.0-9.xml"
errata = []
for k, v in opts:
  if k == "-e" or k == "--regexp": regexp = True
  if k == "-s" or k == "--spec": spec = v
  if k == "-a" or k == "--additional": errata.append(v)

if regexp:
  def match(pattern, value):
    try:
      return re.match(pattern, value)
    except Exception, e:
      die("error: '%s': %s" % (pattern, e))
else:
  def match(pattern, value):
    return fnmatch(value, pattern)

spec = load(spec, *errata)
methods = {}
patterns = args
for pattern in patterns:
  for c in spec.classes:
    for m in c.methods:
      name = pythonize("%s_%s" % (c.name, m.name))
      if match(pattern, name):
        methods[name] = m.define_method(name)

if patterns:
  if methods:
    AMQP = type("AMQP[%s]" % ", ".join(patterns), (), methods)
  else:
    die("no matches")
else:
  AMQP = spec.define_class("AMQP")

help(AMQP)
