&{${CLASS}ContentHeaderProperties.java}
/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

/*
 * This file is auto-generated by ${GENERATOR} - do not modify.
 * Supported AMQP versions:
%{VLIST} *   ${major}-${minor}
 */
 
package org.apache.qpid.framing;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.mina.common.ByteBuffer;

public class ${CLASS}ContentHeaderProperties implements ContentHeaderProperties
{
    private static final Logger logger = LoggerFactory.getLogger(BasicContentHeaderProperties.class);

    /**
     * We store the encoded form when we decode the content header so that if we need to
     * write it out without modifying it we can do so without incurring the expense of
     * reencoding it.
     */
    private byte[] encodedBuffer;

    /**
     * Flag indicating whether the entire content header has been decoded yet.
     */
    private boolean decodedFlag = true;

    /**
     * We have some optimisations for partial decoding for maximum performance. The
     * headers are used in the broker for routing in some cases so we can decode that
     * separately.
     */
    private boolean decodedHeadersFlag = true;

    /**
     * We have some optimisations for partial decoding for maximum performance. The
     * content type is used by all clients to determine the message type.
     */
    private boolean decodedContentTypeFlag = true;

    /**
     * AMQP major and minor version of this instance.
     */
     private byte major;
     private byte minor;
    
    /**
     * Property flags.
     */
    ${pch_property_flags_declare}

    // Header fields from specification
%{FLIST}    ${field_declaration}

    /**
     * Constructor
     */
    public ${CLASS}ContentHeaderProperties(byte major, byte minor)
    {
        this.major = major;
        this.minor = minor;
        
        // Although one flag is initialized per property, the flags are used
        // in ordinal order of the AMQP version represented by this instance,
        // thus the number of flags actually used may be less than the total
        // number defined.
    	${pch_property_flags_initializer}
    }
        
    public int getPropertyListSize()
    {
        if (encodedBuffer != null)
        {
            return encodedBuffer.length;
        }
        else
        {
            int size = 0;
%{FLIST}            ${pch_field_list_size}
            return size;
        }
    }

    private void clearEncodedForm()
    {
        if (!decodedFlag && encodedBuffer != null)
        {
            //decode();
        }
        encodedBuffer = null;
    }

    public void setPropertyFlags(int[] compactPropertyFlags)
        throws AMQProtocolVersionException
    {
        clearEncodedForm();
${pch_compact_property_flags_check}
%{FLIST}            ${pch_set_compact_property_flags}
    }
    
    public int[] getPropertyFlags()
    {
    	int[] compactPropertyFlags = new int[] { 0 };
${pch_compact_property_flags_initializer}
%{FLIST}            ${pch_get_compact_property_flags}
        return compactPropertyFlags;
    }

    public void writePropertyListPayload(ByteBuffer buffer)
    {
        if (encodedBuffer != null)
        {
            buffer.put(encodedBuffer);
        }
        else
        {
%{FLIST}            ${pch_field_list_payload}
        }
    }
    
    public void populatePropertiesFromBuffer(ByteBuffer buffer, int[] propertyFlags, int size)
        throws AMQFrameDecodingException, AMQProtocolVersionException
    {
        setPropertyFlags(propertyFlags);

        if (logger.isDebugEnabled())
        {
            logger.debug("Property flags: " + propertyFlags);
        }
        decode(buffer);
        /*encodedBuffer = new byte[size];
        buffer.get(encodedBuffer, 0, size);
        decodedFlag = false;
        decodedHeadersFlag = false;
        decodedContentTypeFlag = false;*/
    }
    
    private void decode(ByteBuffer buffer)
    {
        //ByteBuffer buffer = ByteBuffer.wrap(encodedBuffer);
        int pos = buffer.position();
        try
        {
%{FLIST}            ${pch_field_list_decode}
	    // This line does nothing, but prevents a compiler error (Exception not thrown)
            // if this block is empty.
            if (false) throw new AMQFrameDecodingException("");
        }
        catch (AMQFrameDecodingException e)
        {
            throw new RuntimeException("Error in content header data: " + e);
        }

        final int endPos = buffer.position();
        buffer.position(pos);
        final int len = endPos - pos;
        encodedBuffer = new byte[len];
        final int limit = buffer.limit();
        buffer.limit(endPos);
        buffer.get(encodedBuffer, 0, len);
        buffer.limit(limit);
        buffer.position(endPos);
        decodedFlag = true;
    }

    private void decodeIfNecessary()
    {
        if (!decodedFlag)
        {
            //decode();
        }
    }

    // Field clear methods
    
%{FLIST}            ${pch_field_clear_methods}

    // Field get methods

%{FLIST}            ${pch_field_get_methods}

    // Field set methods

%{FLIST}            ${pch_field_set_methods}
}
