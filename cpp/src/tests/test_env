#!/bin/sh
#
# Run a test under valgrind.
#

# Use VALGRIND if set, else look on path. 
test -z "$VALGRIND" && VALGRIND=`which valgrind 2>/dev/null`
# No valgrind, just run the command
test -z "$VALGRIND" && { exec  libtool --mode=execute "$@"; exit $?; }

test "$VERBOSE" = yes && set -x
test -z "$vg_log" && vg_log=valgrind.out
rm -f $vg_log

# Dump log file, print a message and exit non-0.
vg_failed() {
    cat $vg_log 1>&2
    echo $1 1>&2
    exit 1
}

# Check for errors in valgrind output.
vg_check()
{
    # Ensure there is an ERROR SUMMARY line.
    grep -E '^==[0-9]+== ERROR SUMMARY:' $vg_log > /dev/null || \
	vg_failed "No valgrind ERROR SUMMARY line in $$vg_failed."
    # Ensure that the number of errors is 0.
    grep -E '^==[0-9]+== ERROR SUMMARY: [^0] ' $vg_log > /dev/null && \
	vg_failed "Valgrind reported errors in $vg_out; see above." 
    # Check for leaks.
    grep -E '^==[0-9]+== +.* lost: [^0]' $vg_log && \
	vg_failed "Found memory leaks (see log file, $vg_log); see above."
    true
}

# libdlclose_noop prevents unloading symbols needed for valgrind output.
preload=.libs/libdlclose_noop.so
# Output to file, only display if there is an error.
opts=--log-file-exactly=$vg_log

LD_PRELOAD=$preload libtool --mode=execute $VALGRIND $opts  -- "$@" || fail=1
vg_check && test -z "$fail"
