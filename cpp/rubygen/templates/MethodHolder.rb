#!/usr/bin/env ruby
$: << ".."                      # Include .. in load path
require 'cppgen'

class MethodHolderGen < CppGen
  
  def initialize(outdir, amqp)
    super(outdir, amqp)
    @namespace="qpid::framing"
    @classname="MethodHolder"
    @filename="qpid/framing/MethodHolder"
  end

  def gen_max_size()
    # Generate program to generate MaxSize.h
    cpp_file("generate_#{@classname}MaxSize_h") {
      @amqp.amqp_methods.each { |m| include "qpid/framing/#{m.body_name}" }
      genl
      include "<algorithm>"
      include "<fstream>"
      genl
      genl "using namespace std;"
      genl "using namespace qpid::framing;"
      genl
      scope("int main(int argc, char** argv) {") {
        genl "size_t maxSize=0;"
        @amqp.amqp_methods.each { |m|
          genl "maxSize=max(maxSize, sizeof(#{m.body_name}));" }
        gen <<EOS
ofstream out("#{@filename}MaxSize.h");
out << "// GENERATED CODE: generated by " << argv[0] << endl;
out << "namespace qpid{ namespace framing { " << endl;
out << "const size_t MAX_METHODBODY_SIZE=" << maxSize << ";" << endl;
out << "}}" << endl;
EOS
      }
    }
  end

  def gen_construct
    cpp_file(@filename+"_construct") {
      include @filename
      @amqp.amqp_methods.each { |m| include "qpid/framing/#{m.body_name}" }
      genl
      namespace(@namespace) { 
        scope("void #{@classname}::construct(const Id& newId) {") {
          scope("switch (newId.first) {") {
            @amqp.amqp_classes.each { |c|
              scope("case #{c.index}: switch(newId.second) {") {
                c.amqp_methods.each { |m|
                  genl "case #{m.index}: blob.construct(in_place<#{m.body_name}>()); break;"
                }}
              genl "break;"
            }}
          genl "id=newId;";
        }}}
  end


  def generate
    gen_max_size
    gen_construct
  end
end

MethodHolderGen.new(Outdir, Amqp).generate();

