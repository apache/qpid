/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.qpid.requestreply;

import java.net.InetAddress;
import java.util.Date;

import javax.jms.*;

import org.apache.log4j.Logger;

import org.apache.qpid.client.AMQConnection;
import org.apache.qpid.client.AMQQueue;
import org.apache.qpid.jms.ConnectionListener;
import org.apache.qpid.jms.Session;
import org.apache.qpid.ping.AbstractPingClient;

/**
 * PingPongBouncer is a message listener the bounces back messages to their reply to destination. This is used to return
 * ping messages generated by {@link org.apache.qpid.requestreply.PingPongProducer} but could be used for other purposes
 * too.
 *
 * <p/>The message id from the received message is extracted, and placed into the reply as the correlation id. Messages
 * are bounced back to the reply-to destination. The original sender of the message has the option to use either a unique
 * temporary queue or the correlation id to correlate the original message to the reply.
 *
 * <p/>There is a verbose mode flag which causes information about each ping to be output to the console
 * (info level logging, so usually console). This can be helpfull to check the bounce backs are happening but should
 * be disabled for real timing tests as writing to the console will slow things down.
 *
 * <p/>When the a message is received, a reply to producer is created for it if it is not the same as the previous
 * message. All subsequent replies are sent using that producer until a different reply to destination is
 * encountered; effectively a last used cache of size 1. Fast because it saves creating the reply producer over and
 * over again when the destination does not change. For a larger fixed set of reply to destinations could turn this
 * into a cache with more elements.
 *
 * <p><table id="crc"><caption>CRC Card</caption>
 * <tr><th> Responsibilities <th> Collaborations
 * <tr><td> Bounce back messages to their reply to destination.
 * <tr><td> Provide command line invocation to start the bounce back on a configurable broker url.
 * </table>
 *
 * @todo Replace the command line parsing with a neater tool.
 *
 * @todo Make verbose accept a number of messages, only prints to console every X messages.
 */
public class PingPongBouncer extends AbstractPingClient implements MessageListener
{
    private static final Logger _logger = Logger.getLogger(PingPongBouncer.class);

    /** The default prefetch size for the message consumer. */
    private static final int PREFETCH = 1;

    /** The default no local flag for the message consumer. */
    private static final boolean NO_LOCAL = true;

    /** The default exclusive flag for the message consumer. */
    private static final boolean EXCLUSIVE = false;

    /** Used to indicate that the reply generator should log timing info to the console (logger info level). */
    private boolean _verbose = false;

    /** Determines whether this bounce back client bounces back messages persistently. */
    private boolean _persistent = false;

    /** Keeps track of the response destination of the previous message for the last reply to producer cache. */
    private Destination _lastResponseDest;

    /** The cached, most recently used reply producer. */
    private MessageProducer _cachedReplyProducer;

    /** The consumer session. */
    private Session _consumerSession;

    /** The producer session. */
    private Session _producerSession;

    /**
     * Creates a PingPongBouncer on the specified producer and consumer sessions.
     *
     * @param brokerDetails
     * @param username
     * @param password
     * @param virtualpath
     * @param queueName
     * @param persistent
     * @param transacted
     * @param selector
     * @param verbose
     * @throws JMSException
     *
     * @throws Exception All underlying exceptions allowed to fall through. This is only test code...
     */
    public PingPongBouncer(String brokerDetails, String username, String password, String virtualpath, String queueName,
                           boolean persistent, boolean transacted, String selector, boolean verbose) throws Exception
    {
        // Create a client id to uniquely identify this client.
        InetAddress address = InetAddress.getLocalHost();
        String clientId = address.getHostName() + System.currentTimeMillis();

        // Connect to the broker.
        setConnection(new AMQConnection(brokerDetails, username, password, clientId, virtualpath));
        _logger.info("Connected with URL:" + getConnection().toURL());

        // Set up the failover notifier.
        getConnection().setConnectionListener(new FailoverNotifier());

        // Create a session to listen for messages on and one to send replies on, transactional depending on the
        // command line option.
        Session consumerSession = (Session) getConnection().createSession(transacted, Session.AUTO_ACKNOWLEDGE);
        Session producerSession = (Session) getConnection().createSession(transacted, Session.AUTO_ACKNOWLEDGE);

        // Create the queue to listen for message on.
        Queue q = new AMQQueue(queueName);
        MessageConsumer consumer = consumerSession.createConsumer(q, PREFETCH, NO_LOCAL, EXCLUSIVE, selector);

        // Hang on to the sessions for the messages and replies.
        _consumerSession = consumerSession;
        _producerSession = producerSession;

        _verbose = verbose;
        _persistent = persistent;

        // Set this up to listen for messages on the queue.
        consumer.setMessageListener(this);
    }

    /**
     * Starts a stand alone ping-pong client running in verbose mode.
     *
     * @param args
     */
    public static void main(String[] args) throws Exception
    {
        System.out.println("Starting...");

        // Display help on the command line.
        if (args.length < 5)
        {
            System.err.println("Usage: <brokerdetails> <username> <password> <virtual-path> <serviceQueue> "
                               + "[<P[ersistent]|N[onPersistent]> <T[ransacted]|N<onTransacted]>] [selector]");
            System.exit(1);
        }

        // Extract all command line parameters.
        String brokerDetails = args[0];
        String username = args[1];
        String password = args[2];
        String virtualpath = args[3];
        String queueName = args[4];
        boolean persistent = ((args.length >= 6) && (args[5].toUpperCase().charAt(0) == 'P'));
        boolean transacted = ((args.length >= 7) && (args[6].toUpperCase().charAt(0) == 'T'));
        String selector = (args.length == 8) ? args[5] : null;

        // Instantiate the ping pong client with the command line options and start it running.
        PingPongBouncer pingBouncer =
            new PingPongBouncer(brokerDetails, username, password, virtualpath, queueName, persistent, transacted, selector,
                                true);
        pingBouncer.getConnection().start();

        System.out.println("Waiting...");
    }

    /**
     * This is a callback method that is notified of all messages for which this has been registered as a message
     * listener on a message consumer. It sends a reply (pong) to all messages it receieves on the reply to
     * destination of the message.
     *
     * @param message The message that triggered this callback.
     */
    public void onMessage(Message message)
    {
        try
        {
            String messageCorrelationId = message.getJMSCorrelationID();

            if (_verbose)
            {
                _logger.info(timestampFormatter.format(new Date()) + ": Got ping with correlation id, "
                             + messageCorrelationId);
            }

            // Get the reply to destination from the message and check it is set.
            Destination responseDest = message.getJMSReplyTo();

            if (responseDest == null)
            {
                _logger.debug("Producer not created because the response destination is null.");

                return;
            }

            // Check if the reply to destination is different to the last message and create a new producer if so.
            if (!responseDest.equals(_lastResponseDest))
            {
                _lastResponseDest = responseDest;

                _logger.debug("About to create a producer.");
                _cachedReplyProducer = _producerSession.createProducer(responseDest);
                _cachedReplyProducer.setDisableMessageTimestamp(true);
                _cachedReplyProducer.setDeliveryMode(_persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
                _logger.debug("After create a producer.");
            }

            // Spew out some timing information if verbose mode is on.
            if (_verbose)
            {
                Long timestamp = message.getLongProperty("timestamp");

                if (timestamp != null)
                {
                    long diff = System.currentTimeMillis() - timestamp;
                    _logger.info("Time to bounce point: " + diff);
                }
            }

            // Correlate the reply to the original.
            message.setJMSCorrelationID(messageCorrelationId);

            // Send the receieved message as the pong reply.
            _cachedReplyProducer.send(message);

            if (_verbose)
            {
                _logger.info(timestampFormatter.format(new Date()) + ": Sent reply with correlation id, "
                             + messageCorrelationId);
            }

            // Commit the transaction if running in transactional mode.
            commitTx(_producerSession);
        }
        catch (JMSException e)
        {
            _logger.debug("There was a JMSException: " + e.getMessage(), e);
        }
    }

    /**
     * A connection listener that logs out any failover complete events. Could do more interesting things with this
     * at some point...
     */
    public static class FailoverNotifier implements ConnectionListener
    {
        public void bytesSent(long count)
        { }

        public void bytesReceived(long count)
        { }

        public boolean preFailover(boolean redirect)
        {
            return true;
        }

        public boolean preResubscribe()
        {
            return true;
        }

        public void failoverComplete()
        {
            _logger.info("App got failover complete callback.");
        }
    }
}
